---
layout: post
title: java.lang package & util classes
---

java.lang package

Object class

protected Object clone() : 객체 자신의 복사본 반환
public boolean equals(Object obj) : 객체 자신과 obj가 같은 객체인지 알려줌
protected void finalize() : Garbage Collector에 의해 자동으로 호출
public Class getClass() : 객체 자신의 클래스 정보를 잠고 있는 class instance 반환
public int hashCode() : hashCode 반환
public String toString() : 객체 자신의 정보를 문자열로 반환

equals(Object obj) : 두 객체의 정보를 참조변수의 값으로 판단

```java
/* Object class에 정의된 equals() */

public boolean equals(Object obj) {
	return (this == obj);
}
```

```java
class EqualsEx1 {
	public static void main(Stirng[] args) {
		Value v1 = new Value(10);
		Value v2 = new Value(10);					// 서로 다른 객체 생성

		if(v1.equals(v2))							// v1 != v2
			System.out.println("v1 == v2");
		else
			System.out.println("v1 != v2");

		v2 = v1;									// 같은 객체 가리킴

		if(v1.equals(v2))							// v1 == v2
			System.out.println("v1 == v2");
		else
			System.out.println("v1 != v2");
		
	}
}

class Value {
	int value;

	Value(int value) {
		this.value = value;
	}
}
```

주소값이 같은지 판별하는 것이 아니라 값이 같은지 판별하기 위해서는 equals를 overriding하여 사용한다.

```java
class Value {
	int value;

	Value(int value) {
		this.value = value;
	}

	public boolean equals(Object obj) {
		if(obj instanceof Value)
			return value == ((Value)obj).value;
		else
			return false;
	}
}
```

String class 역시 이와 같이 equals를 overriding 하고있어 값을 비교할 수 있다. Date, File, wrapper class들 역시 overriding 되어있기에 주소값이 아닌 값을 비교한다.

hashCode() : 값이 저장된 위치를 알려주는 hash code를 반환한다.

```java
class HashCodeEx1 {
	public static void main(String[] args) {
		String str1 = new String("abc");
		String str2 = new String("abc");

		System.out.println(str1.equals(str2));
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());					// str1과 같은 결과
		System.out.println(System.identityHashCode(str1));
		System.out.println(System.identityHashCode(str2));		// str1과 다른 결과
	}
}
```

String class의 경우 문자열의 내용이 같으면 같은 hash code를 반환하도록 hashCode()가 오버라이딩 되어있다.
System.identityHashCode(Object obj)는 Object class의 hashCode()처럼 객체의 주소값으로 hash code를 생성하여 항상 다른 hash code값을 반환할 것을 보장한다. 호출 결과는 실행 시 마다 달라진다.

toString() : instance에 대한 정보를 String으로 제공한다.

```java
/* Object class에 정의된 toString() */

public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

toString()을 overriding 하지 않으면 위와 같은 내용을 얻을 수 있다.

```java
class Card {
	String kind;
	int number;

	Card() {
		this("SPADE", 1);
	}

	Card(String kind, int number) {
		this.kind = kind;
		this.number = number;
	}
}

class CardToString {
	public static void main(String[] args) {
		Card c1 = new Card();
		Card c2 = new Card();

		System.out.println(c1.toString());
		System.out.println(c2.toString());		// 다른 인스턴스이므로 hash code도 다름
	}
}
```

```java
class ToStringTest {
	public static void main(String[] args) {
		String str = new String("KOREA");
		java.util.Date today = new java.util.Date();

		System.out.println(str);
		System.out.println(str.toString());
		System.out.println(today);
		System.out.println(today.toString());
	}
}
```

String class는 instance가 가지고 있는 문자열을 반환하도록, 그리고 Date class는 날짜와 시간을 문자열로 변환하여 반환하도록 overriding 되어있다.

clone() : 자신을 복제하여 새로운 instance를 생성한다.

clone()은 단순히 instance 변수의 값만 복사하기 때문에 참조 타입의 instance 변수가 있는 class는 같은 주소를 갖는 경우가 생기므로 clone()을 overriding하여 새로운 객체를 생성하고 내용을 복사하도록 해야한다.

```java
class Point implements Cloneable {	// Cloneable을 구현한 class에서만 clone() 호출 가능
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	public String toString() {
		return "x = " + x + ", y = " + y;
	}

	public Object clone() {			// protected에서 public으로 변경해야 다른 클래스에서 호출 가능
		Object obj = null;

		try {
			obj = super.clone();	// clone()은 반드시 예외 처리 필요
		} catch (CloneNotSupportedException e) {

		}
		
		return obj;
	}
}

class CloneEx1 {
	public static void main(String[] args) {
		Point original = new Point(3,5);
		Point copy = (Point)original.clone();
		System.out.println(original);
		System.out.println(copy);
	}
}
```

covariant return type(공변 반환타입) : overriding시 조상 메소드의 반환타입을 자손 클래스의 타입으로 변경으로 허용한다.

```java
public Point clone() {
	Object obj = null;

	try {
		obj = super.clone();
	} catch (CloneNotSupportedException e) {

	}

	return (Point)obj;
}
```

실제로 반환되는 자손 객체 타입으로 반환 가능하여 일일히 형변환을 할 필요가 없어진다.

배열 역시 Cloneable과 Serializable interface가 구현되어있꼬 clone()이 사용 가능하다.

```java
int[] arr = {1, 2, 3, 4, 5};
int[] arrClone = arr.close();
```

```java
/* 위와 동일한 수행을 하는 코드 */

int[] arr = {1, 2, 3, 4, 5};
int[] arrClone = new int[arr.length];
System.arraycopy(arr, 0, arrClone, 0, arr.length);
```

얕은 복사 / 깊은 복사

Shallow copy(얕은 복사) : 객체에 저장된 값만 복사하고 참조하는 객체는 복사하지 않는다.
- 원본과 복제본이 같은 객체를 공유한다.
- 원본을 변경하면 복사본 역시 영향을 받는다.

Deep copy(깊은 복사) : 원본이 참조하는 객체까지 복제한다.
- 원본과 복사본이 서로 다른 객체를 참조한다.
- 원본이 변경되어도 다른 객체를 참조하기 때문에 복사본은 변경되지 않는다.

```java
class Circle implements Cloneable {
	Point p;
	double r;

	Circle(Point p, double r) {
		this.p;
		this.r;
	}

	public Circle shallowCpoy() {
		Object obj = null;

		try {
			obj = super.clone();
		} catch (CloneNotSupportedException e) {

		}

		return (Circle)obj;
	}

	public Circle deepCopy() {
		Object obj = null;

		try {
			obj = super.clone();
		} catch (CloneNotSupportedException e) {

		}

		return c;
	}

	public String toString() {
		return "[p = " + p + ", r = " + r + " ]";
	}
}

class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	public String toString() {
		return "(" + x + ", " + y + ")";
	}
}

class ShallowDeepCopy {
	public static void main(String[] args) {
		Circle c1 = new Cirecle(new Point(1, 1), 2.0);
		Circle c2 = c1.shallowCopy();
		Circle c3 = c1.deepCopy();

		System.out.println("c1 = " + c1);
		System.out.println("c2 = " + c2);
		System.out.println("c3 = " + c3);

		c1.p.x = 9;
		c1.p.y = 9;

		System.out.println("=== c1 변경 후 ===");
		System.out.println("c1 = " + c1);		// 변경 된 원본
		System.out.println("c2 = " + c2);		// 참조하는 객체가 변경되었으므로 같이 변경됨
		System.out.println("c3 = " + c3);		// 다른 객체를 참조하므로 변경되지 않음
	}
}
```

getClass() : 자신이 속한 클래스의 Class 객체를 반환

Class cObj = new Card().getClass(); : 생성된 객체로부터 얻음
Class cObj = Card.class;			: 클래스 literal로부터 얻음
Class cObj = Class.forName("Card"); : 클래스 이름으로부터 얻음

Card c = new Card()					: new 연산자를 이용해서 객체 생성
Card c = Card.class.newInstance()	: Class 객체를 이용해서 객체 생성

```java
final class Card {
	String kind;
	int num;

	Card() {
		this("SPADE", 1);
	}

	Card(String kind, int num) {
		this.kind = kind;
		this.num = num;
	}

	public String toString() {
		return kind + " : " + num;
	}
}

class ClassEx1 {
	public static void main(String[] args) throws Exception {
		Card c = new Card("HEART", 3);		// new 연산자로 객체 생성
		Card c2 = Card.class.newInstance();	// Class 객체를 통하여 객체 생성

		Class cObj = c.getClass();

		System.out.println(c);							// HEART : 3
		System.out.println(c2);							// SPADE : 1
		System.out.println(cObj.getName());				// Card
		System.out.println(cObj.toGenericString());		// final class Card
		System.out.println(cObj.toString());			// class Card
	}
}
```

String class



---
layout: post
title: OOP2
---
상속

조상 클래스 = 부모(Parent) 클래스, 상위(Super) 클래스, 기반(Base) 클래스
자손 클래스 = 자식(Child) 클래스, 하위(Sub) 클래스, 파생(Derived) 클래스

- 생성자와 초기화블럭은 상속되지 않음. 멤버만 상속됨
- 자손 클래스의 멤버 갯수는 항상 조상 클래스와 같거나 보다 많다.

포함관계

```java
class Point {
	int x;
	int y;
}

class Circle {
	Point c = new Point(); // Point class를 포함
	int r;
}
```

상속관계 is-a
포함관계 has-a

JAVA에서는 single inheritance(단일 상속)만 허용

모든 class는 Object class를 상속받는다.
다른 클래스로부터 상속받지 않는 클래스는 컴파일 시 컴파일러가 자동으로 `extends Object`를 추가한다.

오버라이딩
- 조상클래스의 메소드와 이름 / 매개변수 / 반환타입이 모두 같아야한다.
- 접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
- 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.
- instance method / static method간 전환이 불가능하다.

자신의 멤버 : this
조상의 멤버 : super

조상 클래스의 method를 overriding한 경우 자손클래스에서 super를 이용하여 조상 클래스의 method를 호출할 수 있다.

super() : 조상 클래스의 생성자

Object 클래스를 제외한 모든 클래스는 생성자의 첫 줄에 this() 또는 super()를 호출해야한다. 그렇지 않을 경우 컴파일러가 자동으로 super()를 추가한다.

```java
class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}
```

```java
class Point3D extends Point {
	int z;

	/* 생성자 첫줄에 다른 생성자를 호출하지 않아 자동으로 super()가 삽입되는데 Point class의 기본생성자가 없으므로 오류가 발생함. */
	/*
		Point3D(int x, int y, int z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	*/

	Point3D(int x, int y, int z) {
		super(x, y); // 부모 클래스의 생성자 호출
		this.z = z;
	}
}
```

package : class의 묶음
- 하나의 소스 파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 .을 구분자로 하여 계층구조로 선언할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

package를 지정하지 않으면 자동으로 unnamed package 에 속하게 된다.

import문

import문을 사용하여 다른 클래스의 package를 사용할 수 있다.

```java
import java.package.class;

import java.package.*;
```

```ABCD
ABCD
```
import문은 컴파일 시간에 약간의 영향을 주나 프로그램 자체의 실행성능에는 영향이 없다.

import문에서 \*를 사용하면 하위 클래스들을 모두 포함하나 하위 패키지의 클래스까지는 포함하지 않는다.

java.lang package는 모든 파일에 기본으로 import 되어있다.

static import문을 사용하면 static 멤버를 호출할 때도 클래스 이름을 생략할 수 있다.

```java
import static java.lang.System.out;

out.println("Hello, World!"); // System.out.println("Hello, World!");와 같음
```

제어자(modifier)

접근 제어자 `public` `protected` `default` `private`
그 외 `static` `final` `abstract` `transient` `synchronized` `volatile` `strictfp`

static

- 모든 인스턴스가 공유
- 인스턴스 생성하지 않고도 사용 가능
- 메소드의 경우 인스턴스 멤버 사용 불가능
- 멤버변수, 메소드, 초기화 블럭에서 사용 가능
- 속도가 더 빠르다

final

- 변수의 경우 값을 변경할 수 없음
- 메소드의 경우 오버라이딩이 불가함
- 클래스의 경우 자손 클래스를 정의할 수 없음
- 클래스, 메소드, 멤버변수, 지역변수에서 사용 가능

abstract

- 추상 메소드를 선언하는 데 사용
- 추상 클래스에서는 인스턴스 생성 불가능
- 추상 메소드가 없는 클래스에 인스턴스 생성 방지용으로 사용하기도 함
- 클래스, 메소드에서 사용 가능

접근 제어자(access modifier)

멤버 또는 클래스를 외부에서 접근하지 못하도록 제한한다.

- private : 같은 클래스 내에서만 접근 가능
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 및 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한 없음

public > protected > (default) > private

클래스 : public, (default)
메소드 / 멤버변수 : public, protected, (default), private
캡슐화 : 데이터 감추기. 외부에서 데이터의 직접 접근 및 변경을 막는다.
상속을 통해 확장될 것이 예상된다면 protected, 그 외는 private

- getter : 멤버 변수의 값을 읽는 메소드. getVar()
- setter : 멤버 변수의 값을 변경하는 메소드. setVar()

생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한할 수 있다.
생성자가 private인 경우 다른 클래스에서 조상 클래스의 생성자를 호출할 수 없으므로 조상 클래스가 되는 것이 불가능하기에 앞에 final을 추가해주는 것이 좋다.

- static과 abstract는 함께 사용할 수 없다.
- class에 abstract와 final을 동시에 사용할 수 없다.
- abstract와 private는 함께 사용할 수 없다.
- method에 private와 final을 같이 사용할 필요는 없다.

 polymorphism(다형성)

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있음

```java
class TV {
	boolean power;
	int channel;

	void power() {
		power != power;
	}
	
	void channelUp() {
		++channel;
	}

	void channelDown() {
		--channel;
	}
}

class CaptionTV extends TV {
	String Text;

	void caption() {
		/* Some Function */
	}
}
```

```java
CatpionTV cTv = new CaptionTV(); // CaptionTV 인스턴스의 모든 멤버 사용 가능
TV tv = new CatpionTV(); // 인스턴스는 CaptionTV 타입이나 TV 인스턴스의 멤버들만 사용가능
/* CaptionTV cTv2 = new TV(); */ // 자손타입의 참조변수로 조상타입의 인스턴스 참조 불가능
```

같은 인스턴스여도 참조변수의 타입에 따라 사용할 수 있는 멤버의 갯수가 달라진다.

자손타입 > 조상타입 Up-Casting : 형변환 생략 가능
조상타입 > 자손타입 Down-Casting : 형변환 생략 불가

형변환은 참조변수의 타입만 변경하고 인스턴스는 그대로 유지하므로 인스턴스에는 아무런 영향을 끼치지 않는다.
참조변수의 형변환을 통해서 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절한다.

```java
Class ParentClass {
	String name;
}

Class ChildClass extends ParentClass {
	int number;
}

Class CastingTest {
	public static void main(String args[]) {
		ChildClass childClass1 = new ChildClass();
		ParentClass parentClass1 = null;
		ChildClass childClass2 = null;

		parentClass1 = childClass1;
		// 조상타입으로 형변환
		// parentClass1 = (ParentClass)childClass1;에서 형변환 생략
		// parentClass1로는 number 사용 불가능

		childClass2 = (ChildClass)parentClass1;
		// 다시 자손타입으로 형변환, 이떄는 형변환 생략 불가능
		// ParentClass 타입의 참조변수이지만 원래 ChildClass 타입의 인스턴스이므로 Down-Casting 가능

		ParentClass parentClass2 = new ParentClass();
		ChildClass childClass3 = null;

		/* childClass3 = (ChildClass)parentClass2; */
		// 컴파일 가능하나 실행 시 에러 발생
		// 인스턴스가 조상타입이므로 자손타입으로 형변환 불가능
		// ParentClass parentClass2 = new ChildClass();와 같이 선언해야 컴파일 및 실행 가능
	}
}
```

인스턴스가 조상타입이면 자손타입으로 형변환이 불가능하다.
인스턴스가 자손타입이면 조상타입과 자손타입간 자유로운 형변환이 가능하다.

따라서 참조변수가 참조하는 인스턴스의 타입을 확인하여야 한다.

instanceof : 해당 참조변수가 참조하는 인스턴스의 타입에 따라 true/false 반환

```java
class ParentClass {
	String name;
}

class ChildClass extends ParentClass {
	int number;
}

class
	public static void main(String args[]) {
		ParentClass parentClass = new ParentClass();
		ChildClass childClass = new ChildClass();

		System.out.println(parentClass instanceof ChildClass);  // false
		System.out.println(parentClass instanceof ParentClass); // true
		System.out.println(parentClass instanceof Object);		// true

		System.out.println(childClass instanceof ChildClass);	// true
		System.out.println(childClass instanceof ParentClass);	// true : 조상 타입의 경우도 true
		System.out.println(childClass instanceof Object);		// true

		System.out.println(parentClass.getClass().getName());	// ParentClass
		System.out.println(childClass.getClass().getName());	// ChildClass
	}
```

instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환해도 문제가 없다는 뜻

메소드의 경우 조상 클래스의 메소드가 자손 클래스에서 오버라이딩 된 경우 참조변수와 상관 없이 실제 인스턴스의 메소드가 호출된다.
멤버변수의 경우 조상 클래스 및 자손 클래스에 중복으로 선언되어 있으면 참조변수의 타입에 선언된 멤버변수가 사용된다.
조상 클래스에만 멤버변수가 선언된 경우에는 그대로 상속받은 멤버변수를 사용한다.

```java
class Parent {
	int x = 100;
	
	void method() {
		System.out.println("Parent Method");
	}
}

class Child extends Parent {
	int x = 200;

	void method() {
		System.out.println("Child Method");
	}
}

class BindingTest {
	public static void main(String args[]) {
		Parent p = new Child();
		Child c = new Child();

		System.out.println(p.x); // Parent 타입의 참조변수이므로 Parent의 x값이 출력
		p.method();				 // Child 타입의 인스턴스이므로 Child Method가 출력

		System.out.println(c.x); // Child 타입의 참조변수이므로 Child의 x값이 출력
		c.method();				 // Child 타입의 인스턴스이므로 Child Method가 출력
	}
}
```

매개변수의 다형성

메소드의 매개변수가 조상 클래스 타입의 참조변수이면, 해당 클래스의 자손 타입의 참조변수는 모두 매개변수로 받아들일 수 있다.

```java
class Product {
	int price;
	int bonusPoint;

	Product(int price) {
		this.price = price;
		bonusPoint = (int)(price/10.0);
	}
}

class TV extends Product {
	TV() {
		super(100);
	}

	public String toString() {
		return "TV";
	}
}

class Computer extends Product {
	Computer() {
		super(200);
	}

	public String toString() {
		return "Computer";
	}
}

class Buyer {
	int money = 1000;
	int bonusPoint = 0;

	void buy(Product p) {
		if(money < price) {
			System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
			return;
		}

		money -= p.price;
		bonusPoint += p.bonusPoint;
		System.out.println(p + "을/를 구입하였습니다.");
	}
}

class PolyArgumentTest {
	public static void main(String args[]) {
		Buyer b = new Buyer();

		b.buy(new TV());			// TV가 Product의 자손 클래스
		b.buy(new Computer());		// Computer가 Product의 자손 클래스

		System.out.println("현재 남은 돈은 " + b.money + "만원입니다.");
		System.out.println("현재 보너스 점수는 " + b.bonusPoint + "점입니다.");
	}
}
```

여러 종류의 객체를 배열로 처리

조상타입의 참조변수 배열을 사용하면 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다루는 것이 가능하다.

```java
Product[] item = new Product[10];	// 구입한 제품을 저장하기 위한 배열

void buy(Product p) {
	item[i++] = p;					// TV / Computer 모두 배열의 각 항목에 저장 가능
}
```

Vector class를 사용하면 크기가 동적으로 바뀌는 배열을 사용할 수 있다.
내부적으로 Object 타입의 배열을 가지고 있어 인스턴스를 추가할 수 있다.

`Vector()` : Vector 인스턴스 생성
`boolean add(Object o)` : Vector에 객체 추가
`boolean remove(Object o)` : Vector에서 객체 제거
`boolean isEmpty()` : Vector가 비어있으면 true
`Object get(int index)` : index의 객체 반환. Object형으로 return되므로 형변환이 필요
`int size()` : Vector에 저장된 객체의 갯수 반환

```java
Vector item = new Vector();

void buy(Product p) {
	item.add(p);
}

void refund(Product p) {
	item.remove(p);
}
```

abstract class(추상 클래스) : 추상 메소드를 포함하는 클래스

```java
abstract class abstractClass {
	/* ... */
}
```

- 추상 클래스는 자손 클래스에 의해서만 완성될 수 있다.
- 추상 클래스는 인스턴스를 생성할 수 없다.

abstract method(추상 메소드) : 선언부만 작성하고 구현부는 작성하지 않은 메소드

```java
abstract void abstractMethod(); // 구현은 자손 클래스에서 한다
```

- 조상으로부터 상속받은 추상 메소드 중 하나라도 구현하지 않으면 자손 클래스 역시 추상 클래스로 지정하고, 하위 자손 클래스에서 구현해야 한다.

```java
abstract class FirstClass {
	abstract void firstMethod();
	abstract String secondMethod(int idx);
}

/* firstMethod()만 구현하고 secondMethod()를 구현하지 않았으므로 abstract class여야 한다. */
abstract class SecondClass extends FirstClass {
	void firstMethod() {
		System.out.println("First Method");
	}
}

/* firstMethod()와 secondMethod() 모두 구현했으므로 완성된 class */
class ThirdClass extends FirstClass {
	void firstMethod() {
		System.out.println("Another First Method");
	}

	String secondMethod(int idx) {
		return Integer.toString(idx);
	}
}
```

추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

추상 메소드를 추가하면 자손 클래스에서 이를 반드시 구현하도록 강제할 수 있다.

Interface(인터페이스) : 추상메소드와 상수만을 멤버로 가질 수 있는 추상클래스
- Interface는 일반 메소드나 멤버 변수를 구성원으로 가질 수 없다.
- 모든 멤버 변수는 public static final이어야 하며, 생략 가능하다.
	- 선언된 멤버 변수는 모두 public static final이 된다.
- 모든 메소드는 public abstract가 되며, 생략 가능하다.
	- 선언된 메소드는 모두 public abstract가 된다.
	- JDK 1.8부터 static method / default method를 추가할 수 있다.
- 생략된 제어자를 컴파일러가 컴파일 시 추가한다.

```java
interface InterfaceTest {
	public static final int one = 1;
	final int two = 2;		// public static final int two = 2;
	static int three = 3;	// public static final int three = 3;
	int four = 4;			// public static final int four = 4;

	public abstract int addNumber();
	int subtractNumber();	// public abstract int subtractNumber();
}
```

- Interface는 Interface로부터만 상속받을 수 있으며, 다중 상속이 가능하다.

```java
interface First {
	void firstMethod();
}

interface Second {
	void secondMethod();
}

interface Third extends First, Second {
	/* */
}
```

Interface는 class에 implements를 붙여 구현한다.

```java
class FirstImpl implements First {
	void firstMethod() {
		/* */
	}
}
```

해당 interface를 구현했는지 알아보려면 instanceof를 사용하면 된다(class와 동일).

다중 상속이 필요한 경우 조상 클래스 중 가장 비중이 높은 쪽을 상속받고, 나머지는 interface로 만들어 구현하는 방식을 택하면 된다.

```java
public class TV {
	protected boolean power;
	protected int channel;
	protected int volume;

	public void power() {
		power = !power;
	}

	public void channelUp() {
		++channel;
	}

	public void channelDown() {
		--channel;
	}

	public void volumeUp() {
		++volume;
	}

	public void volumeDown() {
		--volume;
	}
}

public class VCR {
	protected int counter;

	public void play() {
		// play
	}

	public void stop() {
		// stop
	}

	public void reset() {
		counter = 0;
	}

	public int getCounter() {
		return counter;
	}

	public void setCounter(int counter) {
		this.counter = counter;
	}
}

/* VCR class에 정의된 추상 메소드를 가지는 interface를 작성 */
public interface IVCR {
	public void play();
	public void stop();
	public void reset();
	public int getCounter();
	public void setCounter(int counter);
}

public class TVCR extends TV implements IVCR {
	VCR vcr = new VCR();

	public void play() {
		vcr.play();
	}

	public void stop() {
		vcr.stop();
	}

	public void reset() {
		vcr.reset();
	}

	public int getCounter() {
		return vcr.getCounter();
	}

	public void setCounter(int counter) {
		vcr.setCounter(counter);
	}
}
```

자손 클래스의 인스턴스를 조상 타입의 참조변수로 참조하는 것이 가능하고, 인터페이스 역시 구현된 클래스의 조상이므로 해당 인터페이스형의 참조변수로 이를 구현한 클래스의 인스턴스를 참조하는 것이 가능하다.
같은 원리로 메소드의 매개변수로 인터페이스가 사용 가능하다.
리턴 타입으로도 인터페이스가 사용 가능하며, 이때는 이 인터페이스를 구현한 클래스의 인스턴스를 반환한다.

```java
interface Parseable {
	public abstract void parse(String fileName);
}

class ParserManager {
	/* return type이 Parseable 이므로 해당 interface를 구현한 XMLParser/HTMLParser 중 어느쪽이든 Paraesable 형의 참조변수로 리턴할 수 있다 */
	public static Parseable getParser(String type) {
		if(type.equals("XML")) {
			return new XMLParser();
		} else {
			return new HTMLParser();
		}
	}
}

class XMLParser implements Parsable {
	public void parse(String fileName) {
		System.out.println(fileName + " - XML parsing completed");
	}
}

class HTMLParser implements Parsable {
	public void parse(String fileName) {
		System.out.println(fileName + " - HTML parsing completed");
	}
}

class ParserTest {
	public static void main(String args[]) {
		Parseable parser = ParserManager.getParser("XML");
		parser.parse("document.xml");
		parser = ParserManager.getParser("HTML");
		parser.parse("document2.html");
	}
}
```

인터페이스의 장점
- 메소드의 선언부가 정의되어 있으므로 메소드의 완성 여부와 관계 없이 프로그램을 작성하는 것이 가능하다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 동일한 인터페이스를 구현하도록 함으로써 관계를 맺어줄 수 있다.
- 클래스의 선언과 구현이 분리되어 독립적인 프로그래밍이 가능하다.

```java
class RepairableTest {
	public static void main(String[] args) {
		Tank tank = new Tank();
		Dropship dropship = new Dropship();
		Marine marine = new Marine();
		SCV scv = new SCV();

		scv.repair(tank);
		scv.repair(dropship);
		//scv.repair(marine); // Repairable을 구현하지 않음
	}
}

interface Repariable {}

class Unit {
	int hitPoint;
	final int MAX_HP;

	Unit(int hp) {
		MAX_HP = hp;
	}
}

class GroundUnit extends Unit {
	GroundUnit(int hp) {
		super(hp);
	}
}

class AirUnit extends Unit {
	AirUnit(int hp) {
		super(hp);
	}
}

class Tank extends GroundUnit implements Repairable {
	Tank() {
		super(150);		// hp = 150
		hitPoint = MAX_HP;
	}

	public String toString() {
		return "Tank";
	}
}

class Dropship extends AirUnit implements Repairable {
	Dropship() {
		super(125);		// hp = 125;
		hitPoint = MAX_HP;
	}

	public String toString() {
		return "Dropship";
	}
}

class Marine extends GroundUnit {
	Marine() {
		super(40);		// hp = 40;
		hitPoint = MAX_HP;
	}

	public String toString() {
		return "Marine";
	}
}

class SCV extends GroundUnit implements Repairable {
	SCV() {
		super(60);		//hp = 60;
		hitPoint = MAX_HP;
	}

	/*
	  Repairable을 구현한 Tank, Dropship만이 수리 가능하다.
	  매개변수가 interface Repairable 타입이므로 Repariable에 정의된 멤버만 사용 가능하다.
	  그러나 Repairable에는 아무것도 정의되어 있지 않으므로 Unit타입으로 캐스팅하여 Unit에
	  정의된 hitPoint와 MAX_HP를 사용한다.
	 */
	void repair(Repairable r) {
		if(r instanceof Unit) {
			Unit u = (Unit)r;
			while(u.hitPoint != u.MAX_HP) {
				u.hitPoint++;
			}

			System.out.println(u.toString() + "의 수리가 끝났습니다.");
		}
	}
}
```

Interface에 대하여
- Class는 사용하는 쪽(User)과 제공하는 쪽(Provider)이 있다.
- User는 Provider가 제공하는 선언부만 알면 기능을 사용할 수 있다.

```java
/* methodB가 변경되면 class A도 따라서 변경되어야 한다 */
class A {
	public void methodA(B b) {
		b.methodB();
	}
}

class B {
	public void methodB() {
		System.out.println("methodB()");
	}
}

class InterfaceTest {
	public static void main(String[] args) {
		A a = new A();
		a.methodA(new B());
	}
}
```

```java
/* Interface를 통해 구현하는 방식 */

/*
   class A는 interface I를 매개변수로 받으므로, I를 구현한 클래스면 무엇이든 사용 가능하다.
   I를 구현한 클래스가 없어도 문제가 되지 않는다.
 */

class A {
	void autoPlay(I i) {
		i.play();
	}
}

interface I {
	public abstract void play();
}

class B implements I {
	public void play() {
		System.out.println("play in B class");
	}
}

class C implements I {
	public void play() {
		System.out.println("play in C class");
	}
}

class InterfaceTest2 {
	public static void main(String[] args) {
		A a = new A();

		a.autoPlay(new B());	// void autoPlay(I i) 호출, play in B class 출력
		a.autoPlay(new C());	// void autoPlay(I i) 호출, play in C class 출력
	}
}
```

```java
/* Interface를 구현한 class의 instance를 다른 클래스(InstanceManager) 에서 얻어오는 방식 */

class InterfaceTest3 {
	public static void main(String[] args) {
		A a = new A();

		a.methodA();
	}
}

class A {
	void methodA() {
		/*
			InstanceManager를 통해 instance를 받아오므로 instance가 변경되어도 classA는
			수정할 필요가 없다.
		*/
		I i = InstanceManager.getInstance();
		i.methodB();
		System.out.println(i.toString());
	}
}

interface I {
	public abstract void methodB();
}

class B implements I {
	public void methodB() {
		System.out.println("methodB in B class");
	}

	public String toString() {
		return "class B";
	}
}

class InstanceManager {
	public static I getInstance() {
		return new B();		// 다른 인스턴스로 변경하려면 여기만 변경하면 된다.
	}
}
```

static method
- 인스턴스와 관계가 없기 때문에 원래부터 인터페이스에 추가 가능해야 했으나, 추상 메소드만 있어야 한다는 규칙에 예외를 두지 않기위해 추가 불가능했다. JDK 1.8 부터 추가 가능하다.

default method
- interface에 메소드를 추가하면 interface를 구현한 모든 class에서 이 메소드를 구현해야한다.
- 이를 방지하기 위해 기본적인 구현을 제공하기때문에 몸통이 있어야한다.

```java
interface MyInterface {
	void method();		// 추상 메소드
	/* default 메소드 - 구현되어 있으므로 하위 클래스에서 다시 구현하지 않아도 된다. */
	default void newMethod() {
		/* */
	}
}
```

default method 충돌 시 규칙
- 여러 interface 간의 충돌 : interface를 구현한 class에서 default method를 오버라이딩
- default method와 조상 클래스 간의 충돌 : 조상 클래스의 메소드가 우선, default method 무시

```java
class DefaultMethodTest {
	public static void main(String[] args) {
		Child c = new Child();

		/* Overriding */
		c.method1();					// method1() in Child
		/* 부모 클래스 parent가 MyInterface의 default method보다 우선 */
		c.method2();					// method2() in Parent
		/* static method 이므로 instance 생성 없이 호출 가능 */
		MyInterface.staticMethod();		// staticMethod() in MyInterface
		/* static method 이므로 instance 생성 없이 호출 가능 */
		MyInterface2.staticMethod();	// staticMethod() in MyInterface2
	}
}

class Child extends Parent implements MyInterface, MyInterface2 {
	public void method1() {
		System.out.println("method1() in Child");
	}
}

class Parent {
	public void method2() {
		System.out.println("method2() in Parent");
	}
}

interface MyInterface {
	default void method1() {
		System.out.println("method1() in MyInterface");
	}

	default void method2() {
		System.out.println("method2() in MyInterface");
	}

	static void staticMethod() {
		System.out.println("staticMethod() in MyInterface");
	}
}

interface MyInterface2 {
	default void method1() {
		System.out.println("method1() in MyInterface2");
	}

	static void staticMethod() {
		System.out.println("staticMethod() in MyInterface2");
	}
}
```

inner class(내부 클래스)

class 내부에 선언된 class

- instance class(인스턴스 클래스)
	- 외부 클래스의 멤버변수 선언위치에 선언
	- 외부 클래스의 인스턴스 멤버와 같이 사용
- static class(스태틱 클래스)
	- 외부 클래스의 멤버변수 선언위치에 선언
	- 외부 클래스의 static 멤버와 같이 사용
- local class(지역 클래스)
	- 외부 클래스의 메소드나 초기화블럭 안에 선언
	- 선언된 영역 내에서만 사용 가능
- anonymous class(익명 클래스)
	- 킄래스 선언과 객체의 생성을 동시에 함
	- 한번밖에 사용할 수 없음

```java
class InnerEx1 {
	class InstanceInner {
		int iv = 100;
		// static int cv = 100;				// instance class 안에 static 변수를 선언할 수 없음
		final static int CONST = 100;		// final static은 상수이므로 가능
	}

	static class StaticInner {
		int iv = 200;
		static int cv = 200;				// static class 이므로 static 변수 선언 가능
	}

	void myMethod() {
		class LocalInner {
			int iv = 300;
			// static int cv = 300;			// instance 메소드 내부이므로 static 변수를 선언할 수 없음
			final static int CONST = 300;	// final static은 상수이므로 가능
		}
	}

	public static void main(String[] args) {
		System.out.println(InstanceInner.CONST);	// 100
		System.out.println(StaticInner.cv);			// 200
	}
}
```

```java
class InnerEx2 {
	class InstanceInner {}
	static class StaticInner {}

	InstanceInner iv = new InstanceInner();		// 인스턴스 멤버간 직접 접근 가능
	static StaticInner cv = new StaticInner();	// static 멤버간 직접 접근 가능

	static void staticMethod() {
		// InstanceInner obj1 = new InstanceInner();	// static 멤버는 인스턴스 멤버 접근 불가
		StaticInner obj2 = new StaticInner();

		/* static 멤버가 인스턴스 멤버에 접근하기 위해 외부 객체 생성 후 인스턴스 클래스 생성 */
		InnerEx2 outer = new InnerEx2();
		InstanceInner obj1 = outer.new InstanceInner();
	}

	void instanceMethod() {
		/* 인스턴스 메소드에서는 인스턴스 멤버와 static 멤버 모두 접근 가능 */
		InstanceInner obj1 = new InstanceInner();
		StaticInner obj2 = new StaticInner();
		// LocalInner lv =  new LocalInner();			// 메소드 내에 지역적으로 선언된 내부 클래스 접근 불가
	}

	void myMethod() {
		class LocalInner {
			
		}

		LocalInner lv = new LocalInner();
	}
```

```java
class InnerEx3 {
	private int outerIv = 0;
	static int outerCv = 0;

	class InstanceInner {
		/* 인스턴스 클래스에서 외부 클래스의 private 멤버에도 접근 가능 */
		int innerIv = outerIv;
		int innerIv2 = outerCv;
	}

	static lass StaticInner {
		// int staticIv = outerIv;	// static 클래스에서 외부의 인스턴스 멤버에 접근 불가
		static int staticCv = outerCv;
	}

	void myMethod() {
		int lv = 0;
		final int lv2 = 0;	// JDK 1.8부터 자동으로 앞에 final이 붙으므로 생략 가능

		/*
		   지역 클래스는 해당 클래스가 포함된 메소드에 정의된 지역변수 중 final이 붙은 지역변수에만 접근 가능하다.
		   메소드 수행이 끝나면 지역변수가 같이 소멸하기 때문에 지역변수가 이미 소멸된 지역변수를 참조하는 일을 막기 위해
		 */
		/* JDK 1.8부터 지역 클래스에서 접근하는 상위 메소드의 지역변수에 자동으로 final이 붙고, 해당 변수의 값을 변경하려 하면 컴파일 에러가 발생한다. */
		class LocalInner {
			int localIv = outerIv;
			int localIv2 = outerCv;
			int localIv3 = lv;	// JDK 1.8부터 허용
			int localIv4 = lv2;
		}
	}
}
```

```java
class Outer {
	class InstanceInner {
		int iv = 100;
	}

	static class StaticInner {
		int iv = 200;
		static int cv = 300;
	}

	void myMethod() {
		class LocalInner {
			int iv = 400;
		}
	}
}

class InnerEx4 {
	public static void main(String[] args) {
		/* 인스턴스 클래스의 인스턴스를 생성하기 위해 외부 클래스의 인스턴스 생성 */
		Outer oc = new Outer();
		Outer.InstanceInner ii = oc.new InstanceInner();

		System.out.println("ii.iv : " + ii.iv);									// 100
		System.out.println("Outer.StaticInner.cv : " + Outer.StaticInner.cv);	// 300

		/* static 클래스의 인스턴스는 외부 클래스를 생성하지 않아도 생성 가능 */
		Outer.StaticInner si = new Outer.StaticInner();
		System.out.println("si.iv : " + si.iv);									// 200
	}
}
```

외부 클래스가 아닌 다른 클래스에서 내부 클래스를 생성해야 하는 경우는 그 클래스를 내부 클래스로 선언하면 안되는 경우이다.

```java
class Outer {
	int value = 10;

	class Inner {
		int value = 20;

		void method1() {
			int value = 30;

			System.out.println("		   value : " + value);				// 지역 변수
			System.out.println("	  this.value : " + this.value);			// 내부 클래스
			System.out.println("Outer.this.value : " + Outer.this.value);	// 외부 클래스
		}
	}
}

class InnerEx5 {
	public static void main(String[] args) {
		Outer outer = new Outer();
		Outer.Inner inner = outer.new Inner();
		inner.method1();
	}
}
```

anonymous class(익명 클래스)

- 이름이 없는 클래스
- 클래스 선언과 객체의 생성이 동시에 이루어지기 때문에 한번만 사용 가능
- 하나의 객체만 생성 가능

```java
class InnerEx6 {
	Object iv = new Object() {
		void method() { 

		}
	};

	static Object cv = new Object() {
		void method() {

		}
	};

	void myMethod() {
		Object lv = new Object() {
			void method(){

			}
		};
	}
}
```

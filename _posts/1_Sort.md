---
layout: post
title: CS Study 01 - Sort
---

# Sort

---

### 안정 정렬 / 불안정 정렬

##### 안정 정렬(Stable Sort)

input에 중복된 원소가 있는 경우 입력된 순서와 동일하게 정렬된다.

7 **5(1)** 3 **5(2)** 2 -> 2 3 **5(1)** **5(2)** 7

ex) 삽입 정렬(Insertion sort), 버블 정렬(Bubble Sort), 병합 정렬(Merge Sort)

##### 불안정 정렬(Unstable Sort)

input에 중복된 원소가 있는 경우 입력된 순서가 지켜지지 않고 섞여서 정렬될 수 있다.

6 7 **5(1)** 3 **5(2)** -> 3 **5(2)** **5(1)** 6 7

ex) 선택 정렬(Selection Sort), 퀵 정렬(Quick Sort), 힙 정렬(Heap Sort)

---

### 참조 지역성의 원리(Locality)

`Big-O`표기법으로 $O(n log n)$의 시간복잡도를 가지는 경우 실제 시간은 다음과 같이 계산될 수 있다.

$O(n log n) = C \times n log n + \alpha$
이떄 $\alpha$ 는 무시할 수 있지만 $C$는 수행 시간에 영향을 끼치게 된다.

$C$에 영향을 끼치는 대표적인 요인으로 `참조 지역성`이 있다.

메모리의 종류에는 속도가 상대적으로 빠른 cache memory와 보다 느린 main memory가 있다.
최근에 사용한 데이터 및 그 주변에 접근하는 경우 cache memory에서 읽어오게 되므로, 속도가 빠르다.
이에 반해 최근에 사용된 곳과 먼곳에 존재하는 데이터에 접근하는 경우 main memory에서 읽어오게 되고, 속도가 느려진다.

따라서 근처에 있는 데이터들과의 비교가 빈번한 경우 `참조 지역성이 좋다`고 할 수 있고, 반대의 경우 `참조 지역성이 나쁘다`고 할 수 있다.

---

### 대표적인 $O(n log n)$ 정렬

#### 힙 정렬(Heap Sort)

`Heap`을 사용한 정렬로, 항상 최댓값을 가져와도 다음 최댓값을 바로 꺼낼 수 있는 성질을 이용한다.

> 1. 최대 힙 구조의 트리를 만든다. `root`에는 `MAX` 값이 들어가게 된다.
> 2. `MIN` 값을 `MAX`와 바꾸고, 힙에서 `MAX`를 제거한다. 힙의 크기는 1 감소하였다.
> 3. 트리를 다시 최대 힙 구조가 되도록 변경한다. $log n$ 만큼의 시간이 소비된다.
> 4. `2`번과 `3`번 과정을 모든 원소가 트리에서 제외될 때 까지 반복한다.

**장점**

- 추가적인 메모리가 필요하지 않다.
- 최악의 경우에도 항상 $O(n log n)$의 수행시간을 보장한다.

**단점**

- Unstable Sort
- 참조 지역성이 좋지 않다 : 트리 구조에서 인접한 요소와 비교할 때는 index가 2배이거나 0.5배인 요소들과 비교하게 된다.

#### 병합 정렬(Merge Sort)

크게 분할(divide) - 정복(conqure) - 결합(combine) - 복사(copy)의 4 단계로 이루어진다.

> 1. 분할(divide) : 리스트를 절반이나 비슷한 크기로 나눈다.
> 2. 정복(conqure) : 나눈 리스트들을 각각 정렬한다. 재귀적으로 각각의 리스트 역시 동일한 단계를 거친다.
> 3. 결합(combine) : 정렬된 두 리스트를 합쳐 임시 배열에 저장한다.
> 4. 복사(copy) : 임시 배열의 정렬된 리스트를 원래 배열로 복사한다.

**장점**

- Stable Sort
- 최악의 경우에도 항상 $O(n log n)$의 수행시간을 보장한다.

**단점**

- combine 과정에서 추가적인 배열에 복사해야 하기 때문에 메모리 면에서 불리하다.

#### 퀵 정렬(Quick Sort)

`pivot`을 기준으로 분할-정복을 통해 정렬한다. `pivot`의 값에 따라 최악의 경우 $O(n^2)$까지의 복잡도도 가질 수 있으므로, `pivot`을 선택하는것이 성능에 큰 영향을 미친다. `Median-Of-Three`(3개의 값을 랜덤으로 선택한 다음, 그 중 중간값을 `pivot`으로 지정) 등의 방법을 통해 최악의 경우를 피한다.

> 1. 분할할 때 기준으로 쓰일 `pivot`을 정한다.
> 2. 선택한 `pivot`을 기준으로 앞에서부터 `pivot`보다 큰 원소를, 뒤에서부터 `pivot`보다 작은 원소를 선택한다.
> 3. 큰 원소의 index가 작은 원소의 index보다 작은 경우 두 원소를 교환한다.
> 4. 만일 큰 원소의 index가 작은 원소의 index보다 큰 경우, 이미 전체 배열을 탐색했다는 뜻이므로 배열을 둘로 나누고, `pivot`을 그 사이에 위치시킨다. 이 단계에서 `pivot`보다 전에 있는 모든 원소는 `pivot`보다 작고, `pivot`보다 뒤에 있는 원소는 모두 `pivot` 보다 크다.
> 5. 나누어진 각각의 배열에서 단계 `2 ~ 4`를 반복한다.

**장점**

- 다른 정렬에 비해 계속해서 근처의 원소들과 비교하므로 참조 지역성이 좋아 속도가 빠르다.
- 추가 메모리를 필요로 하지 않는다.

**단점**

- Unstable Sort
- 기존의 배열이 이미 정렬되어 있는 경우, 모든 원소를 탐색하기 때문에 최악의 경우 $O(n^2)$의 수행시간을 가지게 된다.
- `pivot`의 설정에 따라 성능이 크게 차이난다.

#### Tim Sort

- `C` 값이 너무 커지지 않고(= 참조 지역성이 좋고)
- 메모리를 적게 사용하며
- 최악의 경우에도 $O(n log n)$을 보장한다.

삽입 정렬(Insertion Sort)는 일반적으로 $O(n^2)$의 수행 시간을 가지지만, 참조 지역성이 뛰어나기 때문에 `n`이 작은 경우 Quick Sort 보다도 빠른 수행시간을 가진다.
=> 전체를 작은 단위로 나누어 Insertion Sort로 정렬한 다음, 그 결과를 병합하면 더 빠른 결과가 나올것이라는 생각에서 출발

전체를 $2^n$개씩의 원소를 가지는 보다 작은 배열로 나눈 뒤, 병합을 실행한다. 너무 잘게 나누어지면 역으로 병합 과정에서 시간이 많이 소요되므로, 주로 32개나 64개로 나누는 방법이 채택된다.

> 1. 각각의 나눈 배열에 대하여, 첫 두 원소의 증감에 따라 해당 배열을 어떻게 정렬할지 정한다.
> 2. 배열의 크기보다 작은 가장 큰 $2^x$에 대하여 $2^x$개의 원소들을 대상으로 이진 삽입 정렬(Binary Insertion Sort)를 실행한다. 이 덩어리를 `minrun`이라 부른다.
> 3. 만일 $2^x$개의 정렬이 끝난 후 나눈 이후에도 `minrun`의 증감을 따르는 원소들이 연속해서 존재한다면 해당 덩어리에 포함시킨다. 이렇게 완성된 덩어리를 하나의 `run`이라 부른다.
> 4. 증가하는 순서로 정렬한다면 감소하는 `run`들을 모두 뒤집어 모든 `run`의 증감이 같도록 만들어준다.
> 5. 모든 `run`이 완성되면 해당 `run`들을 병합한다. 이때, 비슷한 크기끼리 병합하는 경우 가장 효율성이 좋으므로 최대한 비슷한 크기의 `run`을 만들어가며 병합을 진행하기 위해 `Stack`을 사용한다.

- Stack은 항상 다음 조건을 만족시킨다.
  3개의 연속으로 쌓여있는 원소 `A`, `B`, `C`에 대하여
  1.  가장 아래에 있는 원소는 위에 있는 두 원소의 크기의 합보다 크다. ( $\left|C\right| > \left|A + B\right|$ )
  2.  중간의 원소는 맨 위에 있는 원소보다 크다. ( $\left|B\right| > \left|A\right|$ )
- 해당 조건을 만족시키지 않는다면 조건이 만족 될 때 까지 $B$를 $A$와 $C$중 작은 쪽과 병합시킨다.

  > 6. 병합은 다음과 같은 순서로 진행된다.

  1. 병합할 두 `run` 중 작은 `run`을 다른 메모리 공간에 복사한다. -> 작은 `run`만 복사하므로 일반적인 Merge Sort에 비해 메모리가 적게 든다.
  2. 두 `run`중 작은 쪽부터 채워나가면서 병합한다.

> 7. `Galloping` : 병합 과정에서 하나의 `run`에서만 특정 횟수 이상 연속으로 원소가 선택되는 경우 칸을 건너 뛰어가며 속도를 높인다. `k`칸씩 건너 뛰어 원소를 체크하고, 작은 `run`의 원소가 선택되는 경우 건너뛰기 직전의 칸과 해당 칸 사이를 이분탐색하여 원소를 결정한다. galloping mode 에 들어가는 횟수가 많으면 k 값을 감소시켜 보다 자주 확인하고, 반대의 경우 k값을 늘려 빠르게 건너뛴다.

**장점**

- 크기와 상관 없이 속도가 빠르다.
- 최악의 경우에도 $O(n log n)$의 수행시간을 보장한다.
